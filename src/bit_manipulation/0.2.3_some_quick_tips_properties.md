That's an excellent observation, and you're exactly right! It is a fundamental property of the bitwise AND operation. Thinking about these properties is key to solving many problems involving bit manipulation.

Here is a comprehensive list of the common bitwise operators and their properties concerning the value of the result.

***

### ## 1. Bitwise AND (`&`)

* **Property:** The result is **always less than or equal to** the smaller of the two operands.
* **Why?** A bit in the result can only be `1` if the corresponding bits in *both* input numbers are `1`. If either bit is `0`, the resulting bit is `0`. You are essentially turning off bits, which can only make the number smaller or keep it the same. It can never create a `1` where there wasn't one in both numbers.
* **Example:** `12 & 5`
    * `12` = `1100`
    * `5` = `0101`
    * Result = `0100` (which is `4`).
    * Notice that `4` is smaller than both `12` and `5`.

***

### ## 2. Bitwise OR (`|`)

* **Property:** The result is **always greater than or equal to** the larger of the two operands.
* **Why?** A bit in the result is `1` if the corresponding bit in *either* of the input numbers is `1`. You are essentially combining all the `1`s from both numbers. This can only make the number larger or keep it the same.
* **Example:** `12 | 5`
    * `12` = `1100`
    * `5` = `0101`
    * Result = `1101` (which is `13`).
    * Notice that `13` is larger than both `12` and `5`.

***

### ## 3. Bitwise XOR (`^`) - Exclusive OR

* **Property:** The result has **no predictable size relationship**. It can be smaller, larger, or in between the operands.
* **Why?** A bit in the result is `1` only if the corresponding bits in the inputs are *different* (`1` and `0`, or `0` and `1`). Because it sometimes turns bits on and sometimes turns them off, there's no simple "bigger" or "smaller" rule.
* **Example:** `12 ^ 5`
    * `12` = `1100`
    * `5` = `0101`
    * Result = `1001` (which is `9`).
    * Here, `5 < 9 < 12`.

***

### ## 4. Bitwise NOT (`~`)

* **Property:** This operator flips every single bit. For a positive number `X`, the result is **always `-(X + 1)`**.
* **Why?** This is due to how computers store negative numbers using a method called "two's complement." Flipping all the bits of a positive number will always result in its negative counterpart, offset by one.
* **Example:** `~5`
    * `5` (in 8 bits) = `00000101`
    * Flipping gives `11111010`, which in two's complement represents `-6`.
    * The formula holds: `-(5 + 1) = -6`.

***

### ## 5. Left Shift (`<<`)

* **Property:** The result is **larger** and is equivalent to **multiplying by 2** for each position shifted.
* **Why?** Shifting all bits to the left by one position is the binary equivalent of multiplying by 10 in our decimal system. You're moving every digit into a higher-value place.
* **Example:** `5 << 2`
    * This means "shift the bits of 5 to the left by 2 places."
    * `5` = `...00101`
    * Result = `...10100` (which is `20`).
    * The formula holds: `5 * 2^2 = 5 * 4 = 20`.

***

### ## 6. Right Shift (`>>`)

* **Property:** The result is **smaller** and is equivalent to **integer division by 2** for each position shifted.
* **Why?** This is the opposite of the left shift. You are moving every digit into a lower-value place, effectively dividing and discarding any remainder.
* **Example:** `13 >> 1`
    * This means "shift the bits of 13 to the right by 1 place."
    * `13` = `...01101`
    * Result = `...00110` (which is `6`).
    * The formula holds: `13 // 2 = 6`.

### ## Quick Summary Table

| Operator | Symbol | Property | Simple Analogy |
| :--- | :--- | :--- | :--- |
| **AND** | `&` | Result ≤ Smaller Operand | A strict filter |
| **OR** | `|` | Result ≥ Larger Operand | A merger |
| **XOR** | `^` | Unpredictable size | A difference checker |
| **NOT** | `~` | Flips bits (`-(X+1)`) | An inverter |
| **Left Shift** | `<<` | Makes larger (`* 2^N`) | Multiplication |
| **Right Shift** | `>>` | Makes smaller (`/ 2^N`) | Division |

I hope this list gives you a great toolkit for thinking about future bitwise problems! ✨